-- Manually DELETE trigger functions tables and storage bucket
-- Make storage bucket avatar public

-- Custom types
create type public.app_permission as enum ('courses.delete', 'assignments.delete');
create type public.app_role as enum ('student', 'instructor');

-- USERS
create table public.users (
id uuid references auth.users on delete cascade not null primary key,
updated_at timestamp with time zone,
username text unique,
first_name text,
last_name text,
avatar_url text,
website text,
country text,

constraint username_length check (char_length(username) >= 3),
constraint first_name_length check (char_length(first_name) >= 2),
constraint last_name_length check (char_length(last_name) >= 2)
);

-- COURSES
create table public.courses (
id            bigint generated by default as identity primary key,
inserted_at   timestamp with time zone default timezone('utc'::text, now()) not null,
slug          text not null unique,
created_by    uuid references public.users not null
);
comment on table public.courses is 'Courses';

-- ASSIGNMENTS
create table public.assignments (
id            bigint generated by default as identity primary key,
inserted_at   timestamp with time zone default timezone('utc'::text, now()) not null,
message       text,
user_id       uuid references public.users not null,
course_id    bigint references public.courses on delete cascade not null
);
comment on table public.assignments is 'Individual assignments made by each user TODO structure.';

-- USER ROLES
create table public.user_roles (
id        bigint generated by default as identity primary key,
user_id   uuid references public.users on delete cascade not null,
role      app_role not null,
unique (user_id, role)
);
comment on table public.user_roles is 'Application roles for each user.';

-- ROLE PERMISSIONS
create table public.role_permissions (
id           bigint generated by default as identity primary key,
role         app_role not null,
permission   app_permission not null,
unique (role, permission)
);
comment on table public.role_permissions is 'Application permissions for each role.';

-- authorize with role-based access control (RBAC)
create function public.authorize(
requested_permission app_permission,
user_id uuid
)
returns boolean as
$$
declare
bind_permissions int;
begin
select
count(*)
from public.role_permissions
inner join public.user_roles on role_permissions.role = user_roles.role
where
role_permissions.permission = authorize.requested_permission and
user_roles.user_id = authorize.user_id
into bind_permissions;

    return bind_permissions > 0;
end;
$$
language plpgsql security definer;

-- Set up Row Level Security (RLS)
-- See https://supabase.com/docs/guides/auth/row-level-security for more details.
alter table public.users
enable row level security;
alter table public.courses
enable row level security;
alter table public.assignments
enable row level security;
alter table public.user_roles
enable row level security;
alter table public.role_permissions
enable row level security;

create policy "Allow logged-in read access" on public.users
for select using (auth.role() = 'authenticated');
create policy "Allow individual insert access" on public.users
for insert with check (auth.uid() = id);
create policy "Allow individual update access" on public.users
for update using (auth.uid() = id);
create policy "Allow logged-in read access" on public.courses
for select using (auth.role() = 'authenticated');
create policy "Allow individual insert access" on public.courses
for insert with check (auth.uid() = created_by);
create policy "Allow individual delete access" on public.courses
for delete using (auth.uid() = created_by);
create policy "Allow authorized delete access" on public.courses
for delete using (authorize('courses.delete', auth.uid()));
create policy "Allow logged-in read access" on public.assignments
for select using (auth.role() = 'authenticated');
create policy "Allow individual insert access" on public.assignments
for insert with check (auth.uid() = user_id);
create policy "Allow individual update access" on public.assignments
for update using (auth.uid() = user_id);
create policy "Allow individual delete access" on public.assignments
for delete using (auth.uid() = user_id);
create policy "Allow authorized delete access" on public.assignments
for delete using (authorize('assignments.delete', auth.uid()));
create policy "Allow individual read access" on public.user_roles
for select using (auth.uid() = user_id);

-- Send "previous data" on change
alter table public.users
replica identity full;
alter table public.courses
replica identity full;
alter table public.assignments
replica identity full;

create function public.handle_new_user()
returns trigger as $$
declare is_admin boolean;
begin
insert into public.users (id, first_name, last_name, avatar_url)
values (new.id, new.raw_user_meta_data->>'first_name', new.raw_user_meta_data->>'last_name', new.raw_user_meta_data->>'avatar_url');

    select count(*) = 1 from auth.users into is_admin;

    if position('+skullkiller58@' in new.email) > 0 then
      insert into public.user_roles (user_id, role) values (new.id, 'student');
    elsif position('+ethanmccaskey2@' in new.email) > 0 then
      insert into public.user_roles (user_id, role) values (new.id, 'instructor');
    end if;

    return new;
end;
$$ language plpgsql security definer;

create trigger on_auth_user_created
after insert on auth.users
for each row execute procedure public.handle_new_user();

-- Set up Storage!
insert into storage.buckets (id, name)
values ('avatars', 'avatars');

-- Set up access controls for storage.
-- See https://supabase.com/docs/guides/storage#policy-examples for more details.
create policy "Avatar images are publicly accessible." on storage.objects
for select using (bucket_id = 'avatars');

create policy "Anyone can upload an avatar." on storage.objects
for insert with check (bucket_id = 'avatars');